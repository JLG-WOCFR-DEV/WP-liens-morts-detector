# Plan d'amélioration et stratégie de débogage

## Fonctions prioritaires par rapport aux applications professionnelles

- **`blc_schedule_manual_image_scan`** – Contrairement aux scans de liens, aucun identifiant de job ni compteur de tentatives n'est stocké ; la fonction se contente de lancer `wp_schedule_single_event()` et force `is_full_scan` à `true`, ce qui empêche de distinguer un balayage partiel ou de suivre un historique des relances. Les plateformes pro conservent ces métadonnées pour la supervision et la reprise manuelle. 【F:liens-morts-detector-jlg/includes/blc-admin-pages.php†L381-L460】
- **`blc_perform_image_check`** – Le contrôleur d'images est exécuté sans instrumentation ni hook de télémétrie. À la différence de `blc_perform_check()`, aucun métrique (durée, throughput, état du lot) n'est publié pour alimenter l'historique ou les dashboards externes, ce qui laisse l'équipe support sans visibilité en cas de scan long ou bloqué. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L3948-L4005】
- **`blc_update_image_scan_status`** – La structure de statut n'expose ni `job_id` ni journal des transitions et ne notifie aucun hook dédié lors d'un changement d'état, ce qui complique l'audit et l'alignement avec les processus ITIL utilisés par les suites professionnelles. Harmoniser cette fonction avec `blc_update_link_scan_status()` (machine à états, journalisation) permettrait de tracer finement les scans d'images. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L867-L934】【F:liens-morts-detector-jlg/includes/blc-scanner.php†L557-L666】
- **`blc_update_image_scan_status`** – La structure de statut n'expose ni `job_id` ni journal des transitions et ne notifie aucun hook dédié lors d'un changement d'état, ce qui complique l'audit et l'alignement avec les processus ITIL utilisés par les suites professionnelles. Harmoniser cette fonction avec `blc_update_link_scan_status()` (machine à états, journalisation) permettrait de tracer finement les scans d'images. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L867-L934】【F:liens-morts-detector-jlg/includes/blc-scanner.php†L557-L666】
- **`blc_schedule_manual_image_scan`** – Contrairement au parcours des liens, la planification d'images ne retournait aucun identifiant de job ni tentative associée, empêchant de tracer les relances et de synchroniser l'interface avec le scan lancé. Une instrumentation équivalente est attendue côté solutions pro. 【F:liens-morts-detector-jlg/includes/blc-admin-pages.php†L1280-L1358】
- **`JLG\BrokenLinks\Scanner\RemoteRequestClient`** – Le client gère désormais la rotation des User-Agent, le backoff exponentiel et le respect de `Retry-After`, mais reste mono-endpoint : aucun support de pool de proxys, de répartition géographique ou de métriques exportables n'est prévu. Les solutions pro offrent souvent une abstraction réseau capable de basculer entre plusieurs sorties et de publier des temps de réponse détaillés. 【F:liens-morts-detector-jlg/includes/Scanner/RemoteRequestClient.php†L17-L168】
- **`blc_schedule_automated_report_generation`** – La vérification d'un événement déjà planifié repose sur `wp_next_scheduled()` avec le contexte complet, mais `blc_normalize_report_context()` y injecte un `completed_at` recalculé à chaque appel. Les arguments diffèrent donc entre deux déclenchements successifs et la déduplication échoue, ce qui multiplie les jobs concurrents et peut saturer le stockage des exports. Stabiliser les métadonnées utilisées pour la comparaison (ou introduire un identifiant persistant) est nécessaire pour garantir l'idempotence. ✅ La normalisation accepte désormais un drapeau `stabilize_completed_at` qui réutilise `ended_at` ou `0` pour éviter les doublons lors de la planification. 【F:liens-morts-detector-jlg/includes/blc-reporting.php†L88-L166】
## Tests de débogage ajoutés

- **`Tests\BlcManualScanSchedulingTest`** : une suite PHPUnit/Brain Monkey qui vérifie le comportement de `blc_schedule_manual_link_scan` lorsque la planification échoue, lorsqu'elle réussit et lorsque le déclenchement manuel via `spawn_cron()` échoue. Ces tests facilitent l'identification rapide des régressions liées à la fiabilité de la planification. 【F:tests/BlcManualScanSchedulingTest.php†L1-L224】
- **`Tests\LinkScanStatusTest`** : couvre le cache mémoire par requête, la purge via `blc_reset_link_scan_status()` et les métriques exposées dans le payload (pourcentage d'avancement, débit par minute, temps restant estimé). Ces assertions détectent les régressions de performance et garantissent la cohérence des données présentées à l'interface. 【F:tests/LinkScanStatusTest.php†L12-L187】
- **`Tests\BlcReportExportsTest`** : vérifie la synchronisation de la planification d'exports, la génération de CSV lorsqu'un scan est terminé et l'enregistrement des tentatives ignorées pour éviter les doublons. Ces tests sécurisent l'itération sur les rapports automatisés. 【F:tests/BlcReportExportsTest.php†L1-L357】
- **`Tests\BlcAutomatedReportTest`** : couvre la nouvelle API `blc_schedule_automated_report_generation()` et `blc_generate_automated_report_csv()`, garantit l'ajout du préfixe anti-formule, la suppression des fichiers partiels lors d'un échec d'écriture et la publication des hooks d'observabilité après chaque run. 【F:tests/BlcAutomatedReportTest.php†L1-L339】
- **`Tests\BlcAutomatedReportTest::test_schedule_automated_report_generation_deduplicates_existing_events`** : simule deux appels successifs avec la même charge utile et des horodatages système différents afin de vérifier que l'argument `completed_at` reste stable et qu'un seul événement `wp_schedule_single_event()` est enregistré. 【F:tests/BlcAutomatedReportTest.php†L173-L230】

## Améliorations réalisées

- **`blc_get_link_scan_status_payload`** calcule désormais des métriques opérationnelles (pourcentage d'avancement, éléments restants, durée, débit par minute, estimation d'achèvement) et les expose à l'interface et à l'API REST pour un suivi plus transparent. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L10-L102】【F:liens-morts-detector-jlg/includes/blc-scanner.php†L366-L408】
- **`blc_get_link_scan_status`** et **`blc_get_image_scan_status`** utilisent un cache mémoire par requête pour limiter les lectures répétitives de la base de données lors d'appels successifs, améliorant la charge serveur pendant les écrans de suivi. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L10-L102】【F:liens-morts-detector-jlg/includes/blc-scanner.php†L446-L544】
- **Exports automatisés** : une nouvelle planification `blc_generate_report_exports` sérialise les résultats du dernier scan en CSV dans `wp-content/uploads/blc-report-exports`, mémorise les tentatives et évite les re-générations inutiles. 【F:liens-morts-detector-jlg/includes/blc-reports.php†L1-L330】【F:liens-morts-detector-jlg/includes/blc-cron.php†L626-L742】【F:liens-morts-detector-jlg/includes/blc-activation.php†L81-L118】

> ✅ `blc_update_image_scan_status` conserve maintenant un journal d'audit (transitions valides/invalides), persiste l'historique des jobs et propage `job_id`, `attempt` et `scheduled_at` pour l'observabilité, offrant un suivi équivalent à celui des scans de liens. 【F:liens-morts-detector-jlg/includes/blc-scanner.php†L1109-L1285】【F:tests/LinkScanStatusTest.php†L294-L372】
> ✅ `blc_schedule_manual_image_scan` génère un identifiant de job déterministe, retente la planification en cas d'échec, journalise le contexte et renvoie les métadonnées nécessaires à l'interface et aux appels AJAX. 【F:liens-morts-detector-jlg/includes/blc-admin-pages.php†L1280-L1366】【F:liens-morts-detector-jlg/includes/blc-admin-pages.php†L3698-L3771】

## Tests manuels recommandés

1. **Validation cron avancée** – Utiliser WP-CLI (`wp cron event run blc_manual_check_batch`) pour confirmer que les événements planifiés via l'interface aboutissent bien en environnement réel et mesurer le délai de lancement.
2. **Observation réseau** – Lancer un scan complet tout en surveillant les requêtes sortantes (via un proxy ou `tcpdump`) pour détecter les éventuelles limitations dues à l'absence de gestion de débit et d'en-têtes adaptés.
3. **Simulation d'échec répété** – Configurer un site de test où `wp_schedule_single_event` renvoie `false` (via un mu-plugin) afin d'observer la résilience réelle de la file d'attente et confirmer les besoins en retries automatiques.
4. **Déduplication des exports automatisés** – Planifier deux exports consécutifs (interface ou `blc_schedule_automated_report_generation()` appelé deux fois) puis inspecter la table `wp_options` (`cron` + `blc_automated_report_index`) pour valider qu'un seul événement est présent. En cas de doublon, comparer les arguments et mesurer la dérive de `completed_at`.

## Scénarios de tests automatisés à prioriser

- ✅ Ajouter un test Brain Monkey qui appelle `blc_schedule_automated_report_generation()` deux fois avec le même contexte tout en modifiant la valeur retournée par `time()`. Le test doit affirmer qu'un seul appel à `wp_schedule_single_event()` est réalisé, garantissant l'idempotence malgré la variation de `completed_at`.

## Commandes de test automatisées

```bash
composer install
vendor/bin/phpunit --filter BlcManualScanSchedulingTest
vendor/bin/phpunit --filter BlcAutomatedReportTest
```
Ces commandes garantissent que les stubs nécessaires sont en place et que les suites de planification manuelle et de rapports automatisés s'exécutent correctement.
